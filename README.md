<div align="center">
  <img src="https://raw.githubusercontent.com/vercube/vercube/refs/heads/main/.github/assets/cover.png" width="100%" alt="Vercube - Unleash your server development." />
  <br>
  <br>

  [Website](https://vercube.dev) â€¢ [Documentation](https://vercube.dev/docs/getting-started) â€¢ [Discord](https://discord.gg/safphS45aN)

</div>

# Vercube Benchmarks

Performance comparison of **Vercube** against other popular solutions on the market.

## ğŸ“Š Current Benchmarks

> Last updated: *Auto-generated by GitHub Actions*

This benchmark suite compares **Vercube** with established Node.js frameworks to demonstrate its performance characteristics in real-world scenarios.

### Tested Solutions

- **ğŸš€ Vercube** ([vercube.dev](https://vercube.dev)) - Modern, fast, TypeScript-first framework
- **NestJS** ([nestjs.com](https://nestjs.com)) - Progressive Node.js framework
- **Routing Controllers** ([github.com/typestack/routing-controllers](https://github.com/typestack/routing-controllers)) - Decorator-based routing

### Results Summary

<!-- BENCHMARK_RESULTS_START -->
### Results Summary

> Last updated: Tuesday, January 6, 2026 at 12:52 AM UTC

> Statistical comparison powered by [hyperfine](https://github.com/sharkdp/hyperfine)

#### âš¡ Build Time

| Framework | Mean | Median | Min | Max | Relative |
|-----------|------|--------|-----|-----|:--------:|
| **vercube** ğŸ† | 0.57s | 0.57s | 0.55s | 0.58s | 1.00Ã— |
| **routing-controllers** | 0.74s | 0.74s | 0.73s | 0.76s | 1.00Ã— |
| **nestjs** | 1.83s | 1.82s | 1.77s | 1.91s | 1.00Ã— |

#### ğŸš€ Cold Start Time

| Framework | Mean | Median | Min | Max | Relative |
|-----------|------|--------|-----|-----|:--------:|
| **vercube** ğŸ† | 585ms | 585ms | 542ms | 673ms | 1.00Ã— |
| **routing-controllers** | 664ms | 658ms | 630ms | 729ms | 1.00Ã— |
| **nestjs** | 745ms | 743ms | 690ms | 832ms | 1.00Ã— |

#### ğŸ”¥ Load Test Performance

| Framework | Requests/sec | Latency p50 | Latency p95 | Latency p99 | vs Best RPS | vs Best p95 |
|-----------|--------------|-------------|-------------|-------------|:-----------:|:-----------:|
| **vercube** ğŸ† | 40249 | 18.00ms | 36.00ms | 38.00ms | â€” | â€” |
| **nestjs** | 36609 | 20.00ms | 41.00ms | 42.00ms | -10% | +14% |
| **routing-controllers** | 34979 | 21.00ms | 43.00ms | 44.00ms | -15% | +19% |

#### ğŸ’¾ Resource Usage

| Framework | CPU Mean | CPU p95 | Memory Mean | Memory p95 | vs Best CPU | vs Best Mem |
|-----------|----------|---------|-------------|------------|:-----------:|:-----------:|
| **vercube** | 0.1% | 0.0% | 130.6MB | 130.6MB | +73% | +1% |
| **nestjs** ğŸ† | 0.0% | 0.0% | 129.8MB | 129.8MB | â€” | â€” |
| **routing-controllers** | 0.1% | 0.0% | 130.8MB | 130.8MB | +109% | +1% |

---

ğŸ“Š [View raw data](results/latest.json)

**Test environment:** Ubuntu 22.04, Node.js 22, 100 concurrent connections, 30s duration
<!-- BENCHMARK_RESULTS_END -->

---

## ğŸš€ Quick Start

### Prerequisites

- **Bun** - For running benchmark scripts ([bun.sh](https://bun.sh))
- **Node.js 22+** - For running framework applications
- **pnpm 10+** - Package manager
- (Optional) Docker for isolated testing

### Running Benchmarks Locally

```bash
# 1. Clone the repository
git clone https://github.com/vercube/benchmarks
cd benchmark

# 2. Setup (installs dependencies and required tools)
pnpm run benchmark:setup

# 3. Run complete benchmark suite
pnpm run benchmark

# 4. View results
open results/report.html
```

---

## ğŸ“‹ Why These Benchmarks Matter

When choosing a framework, performance is crucial. These benchmarks help you understand:

- **How Vercube performs** compared to established solutions
- **Real-world metrics** that impact your application (not synthetic tests)
- **Trade-offs** between different approaches (decorator-based, DI containers, etc.)

All frameworks are tested with identical endpoints and configuration for fair comparison.

---

## ğŸ“‹ Benchmark Methodology

### 1. Build Time

**What it measures:** Time to compile TypeScript and bundle the application.

**Tool:** [hyperfine](https://github.com/sharkdp/hyperfine)

**Command:**
```bash
hyperfine --warmup 3 --runs 10 'pnpm build'
```

**Why it matters:** Faster builds = better developer experience, especially in CI/CD pipelines.

---

### 2. Cold Start Time

**What it measures:** Time from process start to first HTTP response.

**Tool:** hyperfine + custom script

**Command:**
```bash
hyperfine --warmup 0 --runs 20 \
  --prepare 'pkill -f "node dist/main.js" || true' \
  './scripts/cold-start.sh'
```

**Why it matters:** Critical for serverless deployments (AWS Lambda, CloudFlare Workers) and container scaling.

---

### 3. Requests Per Second (RPS)

**What it measures:** Maximum throughput under sustained load.

**Tool:** [autocannon](https://github.com/mcollina/autocannon)

**Command:**
```bash
autocannon -c 100 -d 30 -p 10 http://localhost:3000/api/test
```

Parameters:
- `-c 100`: 100 concurrent connections
- `-d 30`: 30 seconds duration
- `-p 10`: 10 pipelined requests per connection

**Why it matters:** Higher RPS = better scalability and lower infrastructure costs.

---

### 4. Latency (p95)

**What it measures:** 95th percentile response time (95% of requests complete faster than this).

**Tool:** autocannon (same as RPS test)

**Why it matters:** Better user experience. p95 is more reliable than average, as it shows performance under realistic conditions.

---

### 5. Resource Usage (RAM & CPU)

**What it measures:** Memory and CPU consumption during load testing.

**Tool:** pidstat + custom Node.js monitor

**Command:**
```bash
node scripts/monitor.js <PID> > metrics.json
```

Samples every 100ms during the load test.

**Why it matters:** Lower resource usage = more cost-effective deployment and better density per server.

---

## ğŸ—ï¸ Adding Competing Solutions

Want to compare Vercube with other frameworks like Hono, Fastify, or Elysia? It's easy to add new competitors to this benchmark suite.

### Step 1: Create the app structure

```bash
mkdir -p apps/hono
cd apps/hono
```

### Step 2: Copy the template

```bash
cp -r ../vercube/package.json .
cp -r ../vercube/tsconfig.json .
```

### Step 3: Implement the test endpoint

Create `src/main.ts`:

```typescript
// Example for any framework
import { createServer } from 'your-framework';

const app = createServer();

// REQUIRED: Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

// REQUIRED: Test endpoint (must match across all frameworks)
app.get('/api/test', (req, res) => {
  res.json({
    message: 'Hello, World!',
    timestamp: Date.now(),
    framework: 'hono'
  });
});

app.listen(3000, () => {
  console.log('Server started on port 3000');
});
```

### Step 4: Update package.json

```json
{
  "name": "benchmark-hono",
  "scripts": {
    "build": "tsc",
    "start": "node dist/main.js",
    "dev": "tsx watch src/main.ts"
  },
  "dependencies": {
    "hono": "latest"
  }
}
```

### Step 5: Register in benchmark config

Edit `benchmark-config.json`:

```json
{
  "frameworks": [
    "vercube",
    "nestjs",
    "routing-controllers",
    "hono"  // Add here
  ]
}
```

### Step 6: Run benchmarks

```bash
pnpm run benchmark
```

That's it! The framework will be automatically included in all tests.

---

## ğŸ› ï¸ Project Structure

```
vercube-benchmarks/
â”œâ”€â”€ apps/                          # Framework implementations
â”‚   â”œâ”€â”€ vercube/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â””â”€â”€ main.ts           # Application entry point
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ nestjs/
â”‚   â””â”€â”€ routing-controllers/
â”‚
â”œâ”€â”€ scripts/                       # Benchmark scripts (Bun + TypeScript)
â”‚   â”œâ”€â”€ benchmark.ts               # Main orchestrator
â”‚   â”œâ”€â”€ cold-start.ts              # Cold start helper
â”‚   â”œâ”€â”€ monitor.ts                 # RAM/CPU monitoring
â”‚   â””â”€â”€ setup.ts                   # Setup script
â”‚
â”œâ”€â”€ results/                       # Generated benchmark data
â”‚   â”œâ”€â”€ raw/                       # JSON results per run
â”‚   â”œâ”€â”€ latest.json                # Latest aggregated results
â”‚   â””â”€â”€ summary.md                 # Markdown summary
â”‚
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ benchmark.yml          # Runs benchmarks
â”‚       â””â”€â”€ update-readme.yml      # Updates this README
â”‚
â”œâ”€â”€ benchmark-config.json          # Framework registry & config
â”œâ”€â”€ package.json                   # Root dependencies
â””â”€â”€ README.md                      # This file
```

---

## ğŸ“Š Understanding the Results

These benchmarks measure what matters in production:

### Build Time
**Why it matters for Vercube users:** Fast builds = better developer experience
- **Good:** < 5 seconds
- **Acceptable:** 5-15 seconds  
- **Slow:** > 15 seconds

### Cold Start
**Why it matters for Vercube users:** Critical for serverless/edge deployments
- **Excellent:** < 100ms (serverless-ready)
- **Good:** 100-500ms
- **Slow:** > 500ms

### RPS (Requests Per Second)
**Why it matters for Vercube users:** Shows raw throughput and scalability
- **High:** > 50,000 req/s
- **Medium:** 20,000-50,000 req/s
- **Low:** < 20,000 req/s

*Note: Results vary based on hardware*

### Latency p95
**Why it matters for Vercube users:** 95% of users experience this or better
- **Excellent:** < 10ms
- **Good:** 10-50ms
- **Acceptable:** 50-100ms
- **Poor:** > 100ms

### Memory Usage
**Why it matters for Vercube users:** Lower memory = lower hosting costs
- **Minimal:** < 50 MB
- **Low:** 50-100 MB
- **Moderate:** 100-200 MB
- **High:** > 200 MB

---

## ğŸ”§ Advanced Usage

### Run full benchmark suite

```bash
pnpm run benchmark
```

### Custom load test parameters

You can run autocannon directly for custom tests:

```bash
# Start a framework server first
cd apps/vercube && pnpm start &

# 200 connections, 60 seconds
autocannon -c 200 -d 60 -p 10 http://localhost:3000/api/test

# With request body
autocannon -c 100 -d 30 -m POST \
  -H "Content-Type: application/json" \
  -b '{"test": true}' \
  http://localhost:3000/api/test
```

### Compare results

Results are saved in `results/raw/` with timestamps. Compare JSON files manually or check `results/latest.json` for the most recent run.

---

## ğŸ³ Docker-based Testing (Optional)

For more consistent results across different machines, you can use Docker:

```bash
# Run benchmarks in isolated container
docker-compose up benchmark

# Results will be in ./results
open results/report.html
```

**Benefits:**
- Same Node.js version everywhere
- Resource limits enforced (2 CPUs, 2GB RAM)
- No interference from other processes
- Reproducible across machines

---

## ğŸ“ˆ CI/CD Integration

Benchmarks run automatically on:
- Every push to `main`
- Every pull request
- Weekly schedule (Mondays at 2 AM UTC)

Results are published to:
- GitHub Actions artifacts
- This README (auto-updated)
- GitHub Pages (optional)

---

## ğŸ¤ Contributing

Want to improve the benchmarks or add a new framework?

1. Fork the repository
2. Add your framework in `apps/your-framework/`
3. Update `benchmark-config.json`
4. Run benchmarks locally
5. Submit a pull request

---

## ğŸ“ Notes on Fairness

- All solutions tested on identical hardware
- All use simple JSON endpoints to isolate framework overhead
- All solutions use their recommended production configurations
- Vercube is compared against mature, well-established frameworks
- Results reflect framework performance, not application code complexity

**For production decisions:** Consider your specific use case, team experience, and ecosystem requirements alongside these metrics.

---

## ğŸš€ About Vercube

Vercube is a modern, TypeScript-first Node.js framework designed for performance and developer experience. These benchmarks demonstrate how it compares to established solutions in the ecosystem.

**Learn more:**
- [Vercube Website](https://vercube.dev)
- [Documentation](https://vercube.dev/docs/getting-started)
- [Discord Community](https://discord.gg/safphS45aN)

---

## ğŸ“œ License

MIT

---

## ğŸ™ Credits

- Benchmarking tools: hyperfine, autocannon, pidstat
- Frameworks: Vercube, NestJS, Routing Controllers
